<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>The ways to load code in ruby | My New Hugo Site</title>
<meta name=keywords content="require,require_relative,autoload,load">
<meta name=description content="Exploring loading mechanisms in Ruby">
<meta name=author content>
<link rel=canonical href=http://example.org/posts/the-ways-to-load-code-in-ruby/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://example.org/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://example.org/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://example.org/favicon-32x32.png>
<link rel=apple-touch-icon href=http://example.org/apple-touch-icon.png>
<link rel=mask-icon href=http://example.org/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="The ways to load code in ruby">
<meta property="og:description" content="Exploring loading mechanisms in Ruby">
<meta property="og:type" content="article">
<meta property="og:url" content="http://example.org/posts/the-ways-to-load-code-in-ruby/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2016-02-18T00:00:00+00:00">
<meta property="article:modified_time" content="2016-02-18T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="The ways to load code in ruby">
<meta name=twitter:description content="Exploring loading mechanisms in Ruby">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://example.org/posts/"},{"@type":"ListItem","position":2,"name":"The ways to load code in ruby","item":"http://example.org/posts/the-ways-to-load-code-in-ruby/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The ways to load code in ruby","name":"The ways to load code in ruby","description":"Exploring loading mechanisms in Ruby","keywords":["require","require_relative","autoload","load"],"articleBody":"前言 本周开始浏览下Discourse源码，发现一个和我们经常组织rails代码的方式不一样的用法，即大量使用require_dependency\n经过一番查找和研究，发现require_dependency主要用于在developement环境下面，加载./lib目录下的class。类似这样的用法： {% highlight ruby %}\n./lib/meta_info.rb class MetaInfo def name\nend end {% endhighlight %}\n{% highlight ruby %}\n./app/models/about.rb require_dependency ‘meta_info’ class About end {% endhighlight %}\n主要目的在于当修改在./lib下的文件后，development环境下的会自动reload所有./lib下面的修改。require无法做到，必须重新启动rails server才行。\n深入研究Ruby中的代码加载机制 但是require_dependency仅仅是在rails中的一个load机制，所以不在这里过多介绍。但是由于好奇使用require_dependency和require之间的差异，所以完整的研究了下ruby下的load机制，他们分别是load, require, require_relative, autoload。例子使用User和Role之间的依赖关系来做比较，主要在User下如何加载Role。以下是Role的definition。 {% highlight ruby %} class Role puts “loading role” def name “admin” end end {% endhighlight%}\n{% highlight ruby%} require ‘forwardable’ #ignore this require class User puts “loading user” extend Forwardable attr_accessor :role def name\nend\ndef_delegator :@role, :name, :role_name end {% endhighlight %} 如果在没有其它任何引用/加载机制下面，直接使用如下代码是会报错的。 {% highlight ruby %} user = User.new user.role = Role.new user.role_name {% endhighlight %} {% highlight bash%} NameError: uninitialized constant Role {% endhighlight%} 因为在没有Role代码加载在程序运行时上下文的情况下，在User类是找不到Role的定义，使用ruby提供了一些代码加载的机制。 那么我们接下来看看这四种不同的机制下面，Ruby是如何加载代码的。\nKernel#load() {% highlight ruby %}\n./user.rb load ‘./role.rb’ {% endhighlight%} 而且在irb环境下面，使用load加载user.rb {% highlight ruby %} 2.2.2 :001  load ‘./user.rb’ loading role loading user = true {% endhighlight %} 由于在代码中特别加入puts ‘loading user’和puts 'loading role'来测试代码加载中的执行机制，所以可以看到在使用load的情况下，user.rb和role.rb的所有代码是经过了一遍go through的，而且由于在user.rb第一行便执行load './role'，所以先print出”loading role“。\nKernel#require() 当把代码修改成这样 {% highlight ruby%}\n./user.rb require ‘./role’ {% endhighlight %} 而且在irb环境下面，使用require加载user.rb {% highlight ruby %} 2.2.2 :001  require ‘./user’ loading role loading user = true {% endhighlight %} 那么现在看来，似乎load与require没有什么区别，但是当我们执行运行第二次代码的时候会如何？ {% highlight ruby %} 2.2.2 :002  require ‘./user’ = false {% endhighlight %} 没有发生任何变化，这是说明在使用require的情况下，运行时上下文已经加载了代码，不会再额外加载，而load会完成再执行一遍。\nKernel#require_relative() 顾名思义require_relative是加载相对路径的代码，为了更好比较require和require_relative当把代码修改如： {% highlight ruby%}\n./user.rb require_relative ‘role’\nrequire ‘role’ {% endhighlight %} 而且在irb环境下面，当执行require_relative，代码成功加载 {% highlight ruby %} 2.2.2 :001  require ‘./user’ loading role loading user = true {% endhighlight %} 但是当执行require的时候，在require 'role'的时候报错了。 {% highlight ruby %} 2.2.2 :001  require ‘./user’ LoadError: cannot load such file – role from /Users/Paul/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in require' from /Users/Paul/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in require' from /Users/Paul/Programming/learning/workouts/require_vs_require_dependency/user.rb:2:in ' from /Users/Paul/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in require' from /Users/Paul/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in require' from (irb):1 from /Users/Paul/.rvm/rubies/ruby-2.2.2/bin/irb:11:in ' {% endhighlight %} 找不到role，这是怎么回事呢？当我们加上./在role前，就是指定了一个相对路径给require。那么怎么解决这个Error呢？两个办法，当使用require保持显式路径，或者在user.rb第一行，加入 {% highlight ruby%} $:.unshift ‘.’ {% endhighlight %} 这一行代码是讲加入当前路径加到$LOAD_PATH中，这样以来运行时上下文便有了当前路径，自然require就可以直接加载role了。require_relative则可以在当前文件的相对路径下加载其它代码。\nKernel#autoload() 保持争取的role加载在user.rb中，我们使用autoload的方式加载试试： {% highlight ruby%} 2.2.2 :001  autoload :User, ‘./user’ = nil 2.2.2 :002  u = User.new loading role loading user = #User:0x007f9cd9279700 {% endhighlight %} 看到输出，可以理解为一种lazy load机制，它推迟了代码加载的阶段，直到最后代码需要调用的时候才会加载。看起来是一种性能较优的加载方式。 但是，当我们使用autoload的时候，如果文件路径错误，很难在没有调用的运行时检查错误。比如： {% highlight ruby %} 2.2.2 :001  autoload :User, ‘./users’ = nil 2.2.2 :002  u = User.new LoadError: cannot load such file – ./users from (irb):2 from /Users/Paul/.rvm/rubies/ruby-2.2.2/bin/irb:11:in ’‘ {% endhighlight %} 代码加载时并没有提示任何错误信息，直到真正有方法的调用，才显示加载错误。\n比较  load需要每次执行代码，使用会带来更多的性能开销。 require需要显式的执行相对文件路径，或者在require之前使用$:.unshift '.'，来加载当前文件路径到$LOAD_PATH中。 require_relative为require提供一种更简单的相对路径使用方式。 autoload在性能开销上有优势，但是对加载错误处理不如其他。  结论  包括很多gems都偏向于使用autoload，最有名的当属rails，个人认为在编程是能有效避免，或者在unit test阶段可以避免加载错误，autoload是一种不错的加载机制。 其次require，但是需要将文件显式的相对路径。  ","wordCount":"349","inLanguage":"en","datePublished":"2016-02-18T00:00:00Z","dateModified":"2016-02-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.org/posts/the-ways-to-load-code-in-ruby/"},"publisher":{"@type":"Organization","name":"My New Hugo Site","logo":{"@type":"ImageObject","url":"http://example.org/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://example.org/ accesskey=h title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
The ways to load code in ruby
</h1>
<div class=post-description>
Exploring loading mechanisms in Ruby
</div>
<div class=post-meta><span title="2016-02-18 00:00:00 +0000 UTC">February 18, 2016</span>
</div>
</header>
<div class=post-content><h3 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h3>
<p>本周开始浏览下<a href=https://github.com/discourse/discourse>Discourse源码</a>，发现一个和我们经常组织rails代码的方式不一样的用法，即大量使用<code>require_dependency</code></p>
<p>经过一番查找和研究，发现<code>require_dependency</code>主要用于在developement环境下面，加载<code>./lib</code>目录下的class。类似这样的用法：
{% highlight ruby %}</p>
<h1 id=libmeta_inforb>./lib/meta_info.rb<a hidden class=anchor aria-hidden=true href=#libmeta_inforb>#</a></h1>
<p>class MetaInfo
def name</p>
<p>end
end
{% endhighlight %}</p>
<p>{% highlight ruby %}</p>
<h1 id=appmodelsaboutrb>./app/models/about.rb<a hidden class=anchor aria-hidden=true href=#appmodelsaboutrb>#</a></h1>
<p>require_dependency &lsquo;meta_info&rsquo;
class About
end
{% endhighlight %}</p>
<p>主要目的在于当修改在<code>./lib</code>下的文件后，development环境下的会自动<strong>reload</strong>所有<code>./lib</code>下面的修改。<code>require</code>无法做到，必须重新启动rails server才行。</p>
<h4 id=深入研究ruby中的代码加载机制>深入研究Ruby中的代码加载机制<a hidden class=anchor aria-hidden=true href=#深入研究ruby中的代码加载机制>#</a></h4>
<p>但是<code>require_dependency</code>仅仅是在rails中的一个load机制，所以不在这里过多介绍。但是由于好奇使用<code>require_dependency</code>和<code>require</code>之间的差异，所以完整的研究了下ruby下的load机制，他们分别是<code>load</code>, <code>require</code>, <code>require_relative</code>, <code>autoload</code>。例子使用User和Role之间的依赖关系来做比较，主要在User下如何加载Role。以下是Role的definition。
{% highlight ruby %}
class Role
puts &ldquo;loading role&rdquo;
def name
&ldquo;admin&rdquo;
end
end
{% endhighlight%}</p>
<p>{% highlight ruby%}
require &lsquo;forwardable&rsquo; #ignore this require
class User
puts &ldquo;loading user&rdquo;
extend Forwardable
attr_accessor :role
def name</p>
<p>end</p>
<p>def_delegator :@role, :name, :role_name
end
{% endhighlight %}
如果在没有其它任何引用/加载机制下面，直接使用如下代码是会报错的。
{% highlight ruby %}
user = User.new
user.role = Role.new
user.role_name
{% endhighlight %}
{% highlight bash%}
NameError: uninitialized constant Role
{% endhighlight%}
因为在没有Role代码加载在程序运行时上下文的情况下，在User类是找不到Role的定义，使用ruby提供了一些代码加载的机制。
那么我们接下来看看这四种不同的机制下面，Ruby是如何加载代码的。</p>
<h4 id=kernelload>Kernel#load()<a hidden class=anchor aria-hidden=true href=#kernelload>#</a></h4>
<p>{% highlight ruby %}</p>
<h1 id=userrb>./user.rb<a hidden class=anchor aria-hidden=true href=#userrb>#</a></h1>
<p>load &lsquo;./role.rb&rsquo;
{% endhighlight%}
而且在<code>irb</code>环境下面，使用load加载user.rb
{% highlight ruby %}
2.2.2 :001 > load &lsquo;./user.rb&rsquo;
loading role
loading user
=> true
{% endhighlight %}
由于在代码中特别加入<code>puts ‘loading user’</code>和<code>puts 'loading role'</code>来测试代码加载中的执行机制，所以可以看到在使用<code>load</code>的情况下，user.rb和role.rb的所有代码是经过了一遍go through的，而且由于在user.rb第一行便执行<code>load './role'</code>，所以先print出”loading role“。</p>
<h4 id=kernelrequire>Kernel#require()<a hidden class=anchor aria-hidden=true href=#kernelrequire>#</a></h4>
<p>当把代码修改成这样
{% highlight ruby%}</p>
<h1 id=userrb-1>./user.rb<a hidden class=anchor aria-hidden=true href=#userrb-1>#</a></h1>
<p>require &lsquo;./role&rsquo;
{% endhighlight %}
而且在<code>irb</code>环境下面，使用require加载user.rb
{% highlight ruby %}
2.2.2 :001 > require &lsquo;./user&rsquo;
loading role
loading user
=> true
{% endhighlight %}
那么现在看来，似乎<code>load</code>与<code>require</code>没有什么区别，但是当我们执行运行第二次代码的时候会如何？
{% highlight ruby %}
2.2.2 :002 > require &lsquo;./user&rsquo;
=> false
{% endhighlight %}
没有发生任何变化，这是说明在使用<code>require</code>的情况下，运行时上下文已经加载了代码，不会再额外加载，而<code>load</code>会完成再执行一遍。</p>
<h4 id=kernelrequire_relative>Kernel#require_relative()<a hidden class=anchor aria-hidden=true href=#kernelrequire_relative>#</a></h4>
<p>顾名思义<code>require_relative</code>是加载相对路径的代码，为了更好比较<code>require</code>和<code>require_relative</code>当把代码修改如：
{% highlight ruby%}</p>
<h1 id=userrb-2>./user.rb<a hidden class=anchor aria-hidden=true href=#userrb-2>#</a></h1>
<p>require_relative &lsquo;role&rsquo;</p>
<h1 id=require-role>require &lsquo;role&rsquo;<a hidden class=anchor aria-hidden=true href=#require-role>#</a></h1>
<p>{% endhighlight %}
而且在<code>irb</code>环境下面，当执行require_relative，代码成功加载
{% highlight ruby %}
2.2.2 :001 > require &lsquo;./user&rsquo;
loading role
loading user
=> true
{% endhighlight %}
但是当执行require的时候，在<code>require 'role'</code>的时候报错了。
{% highlight ruby %}
2.2.2 :001 > require &lsquo;./user&rsquo;
LoadError: cannot load such file &ndash; role
from /Users/Paul/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in <code>require' from /Users/Paul/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in </code>require'
from /Users/Paul/Programming/learning/workouts/require_vs_require_dependency/user.rb:2:in <code>&lt;top (required)>' from /Users/Paul/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in </code>require'
from /Users/Paul/.rvm/rubies/ruby-2.2.2/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in <code>require' from (irb):1 from /Users/Paul/.rvm/rubies/ruby-2.2.2/bin/irb:11:in </code>'
{% endhighlight %}
找不到role，这是怎么回事呢？当我们加上<code>./</code>在role前，就是指定了一个相对路径给<code>require</code>。那么怎么解决这个Error呢？两个办法，当使用require保持显式路径，或者在user.rb第一行，加入
{% highlight ruby%}
$:.unshift &lsquo;.&rsquo;
{% endhighlight %}
这一行代码是讲加入当前路径加到<code>$LOAD_PATH</code>中，这样以来运行时上下文便有了当前路径，自然<code>require</code>就可以直接加载role了。<code>require_relative</code>则可以在当前文件的相对路径下加载其它代码。</p>
<h4 id=kernelautoload>Kernel#autoload()<a hidden class=anchor aria-hidden=true href=#kernelautoload>#</a></h4>
<p>保持争取的role加载在user.rb中，我们使用<code>autoload</code>的方式加载试试：
{% highlight ruby%}
2.2.2 :001 > autoload :User, &lsquo;./user&rsquo;
=> nil
2.2.2 :002 > u = User.new
loading role
loading user
=> #<a href=User:0x007f9cd9279700>User:0x007f9cd9279700</a>
{% endhighlight %}
看到输出，可以理解为一种lazy load机制，它推迟了代码加载的阶段，直到最后代码需要调用的时候才会加载。看起来是一种性能较优的加载方式。
但是，当我们使用autoload的时候，如果文件路径错误，很难在没有调用的运行时检查错误。比如：
{% highlight ruby %}
2.2.2 :001 > autoload :User, &lsquo;./users&rsquo;
=> nil
2.2.2 :002 > u = User.new
LoadError: cannot load such file &ndash; ./users
from (irb):2
from /Users/Paul/.rvm/rubies/ruby-2.2.2/bin/irb:11:in ’‘
{% endhighlight %}
代码加载时并没有提示任何错误信息，直到真正有方法的调用，才显示加载错误。</p>
<h3 id=比较>比较<a hidden class=anchor aria-hidden=true href=#比较>#</a></h3>
<ul>
<li>load需要每次执行代码，使用会带来更多的性能开销。</li>
<li>require需要显式的执行相对文件路径，或者在require之前使用<code>$:.unshift '.'</code>，来加载当前文件路径到$LOAD_PATH中。</li>
<li>require_relative为require提供一种更简单的相对路径使用方式。</li>
<li>autoload在性能开销上有优势，但是对加载错误处理不如其他。</li>
</ul>
<h3 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h3>
<ul>
<li>包括很多gems都偏向于使用autoload，最有名的当属rails，个人认为在编程是能有效避免，或者在unit test阶段可以避免加载错误，autoload是一种不错的加载机制。</li>
<li>其次require，但是需要将文件显式的相对路径。</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://example.org/tags/ruby-load-code-load-require/>ruby load-code load require</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=http://example.org/>My New Hugo Site</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>